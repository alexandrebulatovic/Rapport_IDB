Les tests constituent des éléments indispensables, ils permettent d'avancer sur un projet sans que les nouvelles implémentations ne viennent modifier le comportement existant.
\section{Pourquoi tester}


Idéalement, chaque classe devrait être testé \textbf{unitairement}.
Malheureusement, certains comportement ne peuvent pas être testé de manière efficiente (= de façon automatique) car par exemple pour tester les fonctionnalités d'un logiciel ayant des interactions avec \gls{sgbd}, il faudrait que l'utilisateur stocke ses identifiants de connexion en dur dans une classe accessible par sa classe de test, et il faudrait également qu'il ait préalablement créé la liste de toutes les tables nécessaires au fonctionnement de son programme.
\bigbreak

Pour pallier à ce problème, il est possible de créer une deuxième classe avec les comportements attendus directement introduits par le développeur (c'est-à-dire que si la classe normale doit effectuer une vérification sur un système externe et retourner \textit{true} ou \textit{false} selon le résultat de cette vérification, la classe mock, elle, retournera directement \textit{true} ou \textit{false} sans faire de vérifications, c'est ce que l'on appelle "\underline{mocker la classe}"). L'inconvénient de cette façon de faire est que cela agrandit considérablement le nombre de classes Java du projet.


\bigbreak
  Heureusement, il existe des bibliothèques externes qui permettent de créer des objets \gls{mock}* sans avoir à créer une nouvelle classe.
Les classes natives de Java ne seront pas "mocké" car celles-ci ont déjà été testées avant d'être intégrées à Java et sont donc considérées "parfaites" (sans bugs).
\bigbreak
Exemple d'utilisation de la bibliothèque externe \textit{Mockito} :

\lstset{
language=Java,
basicstyle=\normalsize, % ou ça==> basicstyle=\scriptsize,
upquote=true,
aboveskip={1.5\baselineskip},
columns=fullflexible,
showstringspaces=false,
extendedchars=true,
breaklines=true,
showtabs=false,
showspaces=false,
showstringspaces=false,
identifierstyle=\ttfamily,
keywordstyle=\color[rgb]{0,0,1},
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\color[rgb]{0.627,0.126,0.941},
}
\begin{lstlisting}
SQLManager sqlManager = Mockito.mock(SQLManager.class);

Mockito.when(sqlManager.sendQuery(Mockito.contains("SELECT"))).thenReturn(true);
Mockito.when(sqlManager.sendQuery("")).thenThrow(IllegalArgumentException.class);
Mockito.when(sqlManager.getGeneratedJTable()).thenReturn(new JTable());
Mockito.when(sqlManager.getGeneratedReply()).thenReturn(Mockito.anyString());

\end{lstlisting}
\bigbreak

Il est utile de tester pour vérifier que les fonctionnalités telles que définies dans le cahier des charges correspondent bien à ce qui a été développé.
\exemple{Un utilisateur doit pouvoir se connecter à la base de données. Si un jour, après une légère modification, l'utilisateur ne peut plus se connecter alors qu'il le devrait, le reste du logiciel deviendrait inutile aux yeux du client\newline}

Certaines classes ne sont pas testables sans utiliser des bibliothèques complexes nécessitant d'écrire des centaines de lignes de code pour tester une seule fonctionnalité, c'est le cas notamment des classes servant d'IHM et dont la seule façon possible de tester est d'implémenter un objet dit "Robot" qui simulera l'action d'un utilisateur humain. Après concertation avec le tuteur du projet il a été décidé que le projet n'utilisera pas ce genre de tests.

\section{Les tests choisis}

Nous avons donc choisis de tester en priorité les classes \textbf{Métiers}, une suite de tests appelée \textbf{AllTests} se charge  de lancer tous les tests liés aux classes métiers : 
\\

\begin{itemize}
	\item testAttribute
	\item testTable
	\item testConstraint
	\item testTableSet
\end{itemize}

\textit{Voir section \ref{section_metiers} traitant des classes métiers}
\\


La plupart des tests ont été écrits après l'implémentation des fonctionnalités, exception faite pour certaines classes utilisant les classes du package \textbf{Métiers} qui ont été développement suivant la technique de \gls{tdd}*.
\medbreak
La classe faisant office de \gls{dao}* pour le \gls{crud} utilise une bibliothèque externe pour pouvoir mocker son comportement : \textbf{Mockito}. Tous les appels à cette classe sont donc capturés et gérés par le développeur directement dans la classe de test une fois celle-ci "mocké", ce qui permet de tester sa couche de contrôle et sa couche de façade sans créer de classes de \gls{mock} supplémentaires.

\medbreak

Les structures de données ResponseData et Response servant à éviter de traiter des exceptions (voir Figure  \ref{uml_classe_response}) sont également testés individuellement, leur place étant importante au sein du projet.

\bigbreak
Des tests sur la connexion sont également effectuées, c'est l'un des éléments clés du projet car toutes les fonctionnalités reposent sur le fait que la connexion est fonctionnelle. Les test d'intégrations ne passent pas si les tests unitaires sur la connexion ne passent pas).

Pour cela, différents objets nécessaire à l'établissement d'une connexion ont été mocké et des tests vérifiant l'état de la connexion sont effectués.

